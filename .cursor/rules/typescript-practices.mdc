---
description: 
globs: 
alwaysApply: false
---
# TypeScript & Raycast Development Practices

## üîß TYPESCRIPT STANDARDS

### Type Safety
- **Use strict TypeScript** - enable all strict mode flags
- **Prefer interfaces over types** for object shapes
- **Use literal types** for model names, provider types, action names
- **Avoid `any`** - use `unknown` or proper type guards instead
- **Generic constraints** for provider-agnostic functions

### Interface Design
```typescript
// ‚úÖ Good - Universal interface with provider-specific extensions
interface AIConfig {
  provider: 'gemini' | 'openai';
  model: {
    // Universal fields first
    modelName: string;
    systemPrompt: string;
    // Provider-specific fields optional
    geminiApiKey?: string;
    openaiApiKey?: string;
  };
}

// ‚úÖ Good - Backward compatibility through extension
interface GemAIConfig extends AIConfig {
  provider: 'gemini';
  model: AIConfig['model'] & {
    geminiApiKey: string; // Required for Gemini
  };
}
```

### Function Signatures
- **Use async/await** consistently, avoid mixing with Promises
- **Generic provider functions** that work with both Gemini and OpenAI
- **Clear parameter typing** for model configurations
- **Return type annotations** for complex functions

### Error Handling
```typescript
// ‚úÖ Good - Specific error types
type AIProviderError = {
  provider: 'gemini' | 'openai';
  originalError: Error;
  userMessage: string;
};

// ‚úÖ Good - Error handling with user feedback
try {
  const result = await provider.sendRequest(config, query);
} catch (error) {
  console.error("Provider error:", error);
  await showToast({
    style: Toast.Style.Failure,
    title: "AI Request Failed",
    message: error.message || "Unknown error"
  });
}
```

## üì± RAYCAST INTEGRATION

### Command Structure
- **Export default function** for each command
- **Use RaycastProps type** for prop typing
- **Handle launchContext** for screenshot integration
- **Consistent UI patterns** across all commands

### UI Components
```typescript
// ‚úÖ Good - Consistent command structure
export default function MyCommand(props: RaycastProps) {
  const aiConfig = buildAIConfig(getCmd(CMD_MY_COMMAND).id, props, fallbackPrompt);
  aiConfig.ui.placeholder = "Custom placeholder...";
  aiConfig.ui.useSelected = false;
  
  return GemAI(aiConfig);
}
```

### Toast Notifications
- **Use appropriate styles** - Success for completion, Failure for errors, Animated for progress
- **Clear, actionable messages** - tell user what happened and what to do
- **Consistent timing** - show progress during long operations

### Form Handling
- **File picker integration** for attachments
- **Validation** before submitting requests
- **Auto-focus** on primary input fields
- **Keyboard shortcuts** for better UX

## üîÑ ASYNC PATTERNS

### Streaming Responses
```typescript
// ‚úÖ Good - Proper async generator handling
async function* sendRequest(config: AIConfig, query: string): AsyncGenerator<ChunkData> {
  for await (const chunk of apiResponse) {
    yield {
      text: chunk.text || '',
      usageMetadata: chunk.usage,
      finishReason: chunk.finishReason
    };
  }
}

// ‚úÖ Good - Consumer pattern
for await (const chunk of provider.sendRequest(config, query)) {
  if (chunk.text) {
    markdown += chunk.text;
    setRenderedText(markdown);
  }
  if (chunk.usageMetadata) {
    usageMetadata = chunk.usageMetadata;
  }
}
```

### Provider Factory Pattern
```typescript
// ‚úÖ Good - Factory with proper error handling
export function createAIProvider(config: AIConfig): AIProvider {
  switch (config.provider) {
    case 'openai':
      if (!config.model.openaiApiKey) {
        throw new Error("OpenAI API key is required");
      }
      return new OpenAIProvider(config.model.openaiApiKey, config.model.openaiBaseUrl);
    
    case 'gemini':
    default:
      if (!config.model.geminiApiKey) {
        throw new Error("Gemini API key is required");
      }
      return new GeminiProvider(config.model.geminiApiKey);
  }
}
```

## üìä STATE MANAGEMENT

### React State Patterns
- **Use useState for UI state** (loading, text content, page state)
- **Use useEffect sparingly** - prefer direct async calls in event handlers
- **Minimize re-renders** - only update state when necessary
- **Local state over global** - keep state close to where it's used

### Configuration Management
- **Immutable configs** - don't modify AIConfig after creation
- **Provider switching** - create new config when switching providers
- **Preference validation** - validate user preferences before using

## üîí SECURITY PRACTICES

### API Key Handling
- **Never log API keys** - even in debug mode
- **Validate key format** before making requests
- **Clear error messages** without exposing sensitive data
- **Handle missing keys gracefully**

### Input Validation
- **Sanitize user input** before sending to AI providers
- **Validate file uploads** - check file types and sizes
- **Rate limiting awareness** - handle API rate limits gracefully

## üìù DOCUMENTATION

### Code Comments
```typescript
// ‚úÖ Good - Explain reasoning model limitations
// Reasoning models (o1-series) don't support system role messages
// Include system prompt in user message instead
if (isReasoningModel) {
  userContent = `${systemPrompt}\n\n---\n\n${userContent}`;
}

// ‚úÖ Good - Document complex token calculations
// Calculate user input tokens by subtracting estimated system tokens
// This is approximate but more accurate than total estimation
const userInputTokens = Math.max(0, promptTokens - systemTokens);
```

### JSDoc for Public APIs
```typescript
/**
 * Creates an AI provider instance based on the configuration
 * @param config - Universal AI configuration
 * @returns Provider instance (GeminiProvider or OpenAIProvider)
 * @throws Error if required API keys are missing
 */
export function createAIProvider(config: AIConfig): AIProvider {
  // Implementation
}
```

## üß™ TESTING CONSIDERATIONS

### Unit Test Patterns
- **Mock provider responses** for consistent testing
- **Test error conditions** - network failures, invalid keys, rate limits
- **Provider-agnostic tests** - same test for both Gemini and OpenAI
- **Configuration validation** - test all config variations

### Integration Testing
- **Screenshot workflow** - test full pipeline with real images
- **Model switching** - verify auto-switching logic
- **Token counting** - compare calculated vs actual tokens
- **UI consistency** - all commands should behave similarly
